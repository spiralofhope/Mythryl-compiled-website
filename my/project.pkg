package project {
# --
# -- Library-candidate functions, project-specific
# --

fun markup( string ) = {
  # FIXME - fuck, all punctuation is broken.
  # FIXME:  _underlined_.   all on one line, will fail.  .$  isn't being caught on the right?

  # TODO:  RENAME
  fun markup_needs_a_name( string: String,  rx_left: String,  rx_right: String,  replace_left: String,  replace_right: String ):   String = {
    fun punctuation_regex( rx_left: String,  rx_right: String ):   String = {
      # TODO:  Why can't I directly use [:graph:], [:space:], etc?
#       graph =  "[\\x21-\\x7E]";   # [\x21-\x7E]  =  [:graph:]  =  printable characters, also doable as [^\s] (not whitespace)
#       punct =  "[^\\32-\\151]";   # [^\32-\151]  =  [:punct:]  =  punctuation
      punct = "/[^!-~]/";
      # FIXME:  Ok, what the fuck.  punct doesn't include a period?!
      punct = punct + "|\\.";
      space =  "\\s";             # \s           =  [:space:]  =  whitespace


      left =
          ""
        + "|" + "^"                                                           # I think this works ok.
        + "|" + space
        ;
      left =
          left
        + "|" + left + punct
        + "|" + left + "\\("
        + "|" + left + "--"
      ;

      right =
          ""
        + "|" + "\\n"                                                   # "$" isn't appropriate for the way I'm doing things.
        + "|" + space
        ;
      right =
          right
        + "|" + punct + right
        + "|" + "\\)" + right
        + "|" + "--"  + right
      ;
      right =
          right
        + "|" + "s"  + right
        + "|" + "es" + right
        + "|" + "ed" + right
      ;

        "("   + left     + ")"
      + "("   + rx_left  + ")"
      + "([^" + rx_left  + "].*[^" + rx_right + "])"
      + "("   + rx_right + ")"
      + "("   + right    + ")"
      ;
    };

    # TODO:  implement split_string_html
    #        then do some kind of:   string =  split_string_html( string );

    rx = punctuation_regex( rx_left, rx_right );
    # TODO:  Implement silent_replace_all_via_fn() ?
    string =  regex::replace_all_via_fn  rx .{
        ( list::nth( #stringlist, 0 ) )
      + replace_left
      + ( list::nth( #stringlist, 2 ) )
      + replace_right
      + ( list::nth( #stringlist, 4 ) )
      ;
    } string
      except
      _ =  string;
    string;
  };



  fun markup_horizontal_rules( string: String ):   String = {
    # With an empty space above and below.
    fun markup_horizontal_rules_long( string: String ):   String = {
      silent_regex_replace_all( ./\n{2}\-{3,}\n{2}/, "\n<hr class=\"long\">\n", string );
    };

    # TODO:  Pull this out of the main markup function, and make separate test cases for this.
    fun markup_horizontal_rules_short( string: String ):   String = {
      hr = "<hr class=\"short\">\n";

      # (with content only above)
      string =  regex::replace_all_via_fn
        ./([^\n])\n-{2,}\n{2}/ .{
            ""
          + strcat( #stringlist )
          + hr
          ;
        } string
          except
          _ =  string;


      # (with content only below)
      string =  regex::replace_all_via_fn
        ./\n{2}-{2,}\n([^\n])/ .{
          "\n"
          + hr
          + strcat( #stringlist )
          ;
        } string
          except
          _ =  string;


      # (with content above and below)
      string =  regex::replace_all_via_fn
        ./\n-{2,}\n([^\n])/    .{
            "\n"
          + hr
          + strcat( #stringlist );
        } string;
      string
        except
        _ =  string;
    };

    string =  markup_horizontal_rules_long ( string );
    string =  markup_horizontal_rules_short( string );
    string;
  };

  fun markup_paragraphs( string: String ):   String = {
    # \n\n  =  Paragraph
    regex::replace_all_via_fn  ./(\n{2,})/ .{
      n =  string::length( strcat( #stringlist ) );
      string_multiplier( "\n<br />", n );
    } string
      except
      _ =  string;
  };

  string =  markup_needs_a_name( string, "\\/", "\\/", "<em>"    , "</em>"     );
  string =  markup_needs_a_name( string, "-"  , "-"  , "<del>"   , "</del>"    );
  string =  markup_needs_a_name( string, "\\*", "\\*", "<strong>", "</strong>" );
  string =  markup_needs_a_name( string, "_"  , "_"  , "<u>"     , "</u>"      );
  string =  markup_horizontal_rules( string );
  string =  markup_paragraphs( string );
  string;
};   # markup( string: String ):   String
# TODO:  Absorb the test cases from the Ruby project.
fun test_markup( _: Void ):   Bool = {
  string =  "test";
  expected =  "test";
  result =  markup( string );
  assert_strings_are_equal( expected, result );

  string =  "\n/emphasis/\n";
  expected =  "\n<em>emphasis</em>\n";
  result =  markup( string );
  assert_strings_are_equal( expected, result );

  string =  "/emphasis/";
  expected =  "<em>emphasis</em>";
  result =  markup( string );
  assert_strings_are_equal( expected, result );

  string =  "/foo/.\n ";
  expected =  "<em>foo</em>.\n ";
  result =  markup( string );
  assert_strings_are_equal( expected, result );

  string = "foo\n--\nbar\n";
  expected = "foo\n<hr class=\"short\">\nbar\n";
  result =  markup( string );
  assert_strings_are_equal( expected, result );
};
# test_markup();



fun rebuild_template( template_filename, compiling_filename ) = {
  if ( exists( template_filename ) == FALSE )
    printf "rebuild_template():  File doesn't exist:  '%s'\n" template_filename;
  else
    # TODO sanity:  Can I read it?  http://mythryl.org/my-Check_File_Readability.html
    # can_read : (Input_Stream , Int) -> Null_Or(Int );
    stream =  open_for_read( template_filename );
    contents =  read_lines( stream );
    contents =  join "" contents;

    page_title =  get_filename( compiling_filename );
    page_title =  remove_extension( page_title );
    # TODO:  Table of Contents
    toc =  "<br>TO DO";
    # TODO:  RSS
    #        rss-feed-icon-16px-svg.png
    rss =  "";

    contents =  silent_regex_replace_all( "<!--SITE NAME-->"         , *site_name         , contents );
    contents =  silent_regex_replace_all( "<!--SITE TAGLINE-->"      , *site_tagline      , contents );
    contents =  silent_regex_replace_all( "<!--SITE URL-->"          , *site_url          , contents );
    contents =  silent_regex_replace_all( "<!--TITLE-->"             ,  page_title        , contents );
    contents =  silent_regex_replace_all( "<!--TOC-->"               ,  toc               , contents );
    contents =  silent_regex_replace_all( "<!--RSS-->"               ,  rss               , contents );
    contents =  silent_regex_replace_all( "<!--COPYRIGHT-->"         , *copyright         , contents );
    contents =  silent_regex_replace_all( ./\#\{compiling_filename\}/,  compiling_filename, contents );
    contents =  silent_regex_replace_all( ./\#\{counter_code\}/      , *counter_code      , contents );


    template_filename =  template_filename + "-rebuilt.html";
    file = file::open_for_write template_filename;
    file::write( file, contents );
    file::flush         file;
    file::close_output  file;
  fi;
};   # rebuild_template( template_filename: String,  compiling_filename: String ):   Void
# TODO:  A proper full test case.
# fun test_rebuild_template( _: Void ):   Bool = {
# };
# test_rebuild_template();



# TODO:  Think up a better name.
fun post_processing( content_string: String ):   String = {
  fun post_processing_redirect( content_string: String ):   String = {
    # TODO:  A case-insensitive match.
    match =  "\\[{2}redirect (.*)\\]{2}";
    if ( ( content_string =~ match ) == FALSE )
      content_string;
    else
      page_name = regex::find_first_group 1  match  content_string;
      content_string =  silent_regex_replace_all( match,  ( "<p>Redirecting to " + page_name + " ...</p>" ),  content_string );
      replace =  "<head><meta http-equiv=\"refresh\" content=\"2;url=" + page_name + ".html\">";
      content_string =  silent_regex_replace_first(  "<head>",  replace,  content_string );
      content_string;
    fi;
  };

  # This removes all content, replacing it with the redirect.  This is a lazy way of having content be local-only.
  fun post_processing_private( content_string: String ):   String = {
    # TODO:  A case-insensitive match.
    match =  "\\[{2}private\\]{2}";
    if ( ( content_string =~ match ) == FALSE )
      content_string;
    else
      "<html><head><meta http-equiv=\"refresh\" content=\"0;url=index.html\"></head><body></body></html>";
    fi;
  };


  content_string =  post_processing_redirect( content_string );
  content_string =  post_processing_private( content_string );

  content_string;
};
# TODO:  A proper full test case.
# fun test_post_processing( _: Void ):   Bool = {
# };
# test_post_processing();



fun rebuild( compiling_filename: String,  target_filename: String ):   Void = {
  if ( exists( compiling_filename ) == FALSE )
    printf "rebuild():  File doesn't exist:  '%s'\n" compiling_filename;
  else
    rebuild_template( *header, compiling_filename );
    rebuild_template( *footer, compiling_filename );

    content_string =                                 strcat( lines( *header + "-rebuilt.html" ) );
    content_string =  content_string + markup( strcat( lines( compiling_filename ) ) );
    content_string =  content_string +               strcat( lines( *footer + "-rebuilt.html" ) );
    content_string =  post_processing( content_string );

    f =  file::open_for_write  target_filename;
    file::write       ( f, content_string );
    file::flush         f;
    file::close_output  f;
  fi;
};
# TODO:  fun test_rebuild  ?



# Take a string, and break it into a list of strings.  That list of strings is odd-even, where odd is of one type and even is of another type.
# The idea is to break a string down so that a function can be applied to specific parts of it.
# For example, I want to apply markup, but not to text inside of blocks of html.
fun block_matcher( string ) = {
  list =  string_to_list( string );

  fun block_matcher_bool( string: String ):   Bool = {
    # TODO:  If the regex is a match.
    if ( string =~ ./^\ *\-/ )
      TRUE;
    else
      FALSE;
    fi;
  };

  result   =  REF [];
  buffer   =  REF "";
  # We begin at an even position, element 0 in the `result` list.
  position =  REF "even";

  # Iterate through the list of strings.
  foreach list .{
    # For each line, refer to a function which gives a Bool result.
    bool =  block_matcher_bool( #e );
    # Based on the Bool, either append to a working string or append to the list and begin an empty working string.

    if ( bool == TRUE )
      if ( *position == "even" )
        # We have a match, but we're in the even position.  Matches are supposed to be placed in the odd position.

        # Dump the buffer into the last element of the result.
        result :=  *result @ [ *buffer ];
        buffer :=  "";

        # Switch to the odd position.
        position :=  "odd";
      fi;
    else  # ( bool == FALSE )
      if ( *position == "odd" )
        # We don't have a match, but we're still in the odd position.  Non-matches are supposed to be placed in the even position.

        # Dump the buffer into the last element of the result.
        result :=  *result @ [ *buffer ];
        buffer :=  "";

        # Switch to the odd position.
        position :=  "even";
      fi;
    fi;
    # Append to the buffer.
    buffer :=  *buffer + #e;

#     print "--v\n";
#     printf "#e       '%s'\n" #e;
#     printf "*buffer  '%s'\n" *buffer;
#     print "*result\n";
#     apply  printf "'%s'\n" *result;
#     print "--^\n";
  };

  *result @ [ *buffer ];
};
fun test_block_matcher = {
  # Not a match
  string =  "nomatch";
  expected =  [ "nomatch" ];
  result =  block_matcher( string );
  assert_lists_of_strings_are_equal( expected, result );

  # Only a match
  string =  "- bullet";
  expected =  [ "", "- bullet" ];
  result =  block_matcher( string );
  assert_lists_of_strings_are_equal( expected, result );

  # Match, not a match
  string =  "- bullet\nytesty\n";
  expected =  [ "", "- bullet\n", "ytesty\n" ];
  result =  block_matcher( string );
  assert_lists_of_strings_are_equal( expected, result );

  # Not a match, match
  string =  "ytesty\n- bullet\n";
  expected =  [ "ytesty\n", "- bullet\n" ];
  result =  block_matcher( string );
  assert_lists_of_strings_are_equal( expected, result );

  # Two consecutive matches only
  string =  "- bullet\n- bullet\n";
  expected =  [ "", "- bullet\n- bullet\n" ];
  result =  block_matcher( string );
  assert_lists_of_strings_are_equal( expected, result );

  # Two consecutive matches, not a match
  string =  "- bullet\n- bullet\nytesty\n";
  expected =  [ "", "- bullet\n- bullet\n", "ytesty\n" ];
  result =  block_matcher( string );
  assert_lists_of_strings_are_equal( expected, result );

  # Not a match, two consecutive matches, not a match
  string =  "foo\n- bullet\n- bullet\nytesty\n";
  expected =  [ "foo\n", "- bullet\n- bullet\n", "ytesty\n" ];
  result =  block_matcher( string );
  assert_lists_of_strings_are_equal( expected, result );

  # Not a match, two consecutive matches
  string =  "foo\n- bullet\n- bullet\n";
  expected =  [ "foo\n", "- bullet\n- bullet\n" ];
  result =  block_matcher( string );
  assert_lists_of_strings_are_equal( expected, result );

  # Oh hell, let's get silly.
  string =  "foo\n- bullet\n- bullet\nbar\nbaz\nargh\n- bullet\nbla\n- bullet\n";
  expected =  [ "foo\n", "- bullet\n- bullet\n", "bar\nbaz\nargh\n", "- bullet\n", "bla\n", "- bullet\n" ];
  result =  block_matcher( string );
  assert_lists_of_strings_are_equal( expected, result );

  # FIXME:  string_to_list() chops out any duplicate \n like here             ---v
  # string =  "foo\n- bullet\n- bullet\nbar\nbaz\nargh\n- bullet\nbla\n- bullet\n\n";
  # expected =  [ "foo\n", "- bullet\n- bullet\n", "bar\nbaz\nargh\n", "- bullet\n", "bla\n", "- bullet\n\n" ];
  # result =  block_matcher( string );
  # assert_lists_of_strings_are_equal( expected, result );
};
# test_block_matcher();



fun test_all_tests( _: Void ):   Bool = {
  test_assert_strings();
  test_string_multiplier();

  # TODO:  Proper assertions.
#   test_list_of_strings_to_columnized_string();

  # TODO:  Proper assertions.
#   test_list_of_strings_to_columnized_string();

  # TODO:  Proper assertions.
#   test_two_strings_to_columnized_string();

  # TODO:  Proper assertions.
#   test_two_lists_of_strings_to_columnized_string();

  test_assert_ints();
  test_assert_bools();
  test_assert_lists_of_strings();
  test_check_directory();

  # TODO:  A proper assertion.
#   test_get_current_directory();

  # TODO:  A proper assertion.
#   test_get_current_directory();

  test_get_filename();
  test_remove_extension();

  # TODO:  test_not_equal
#   test_is_even();

  # TODO:  test_not_equal
#   test_is_odd();

  test_string_to_list();
  test_pad_string_list();
  test_longest_string_in_a_list_of_strings();

  # TODO:  A proper assertion.
#   test_read_print();

  # TODO:  A proper assertion.
#   test_write_file();

  test_markup();
  test_block_matcher();
};
test_all_tests();

};
