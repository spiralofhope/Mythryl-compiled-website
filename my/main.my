#!/usr/bin/mythryl
# NOTE:  This script assumes that it will be run from the same directory it is found in.

# Does load order matter?
# What happens when one library has requirements from another?
load "main.lib";

{
# TODO:  Trap exceptions for file operations.  Determine what other functions have exceptions.

# --

verbose =  REF TRUE;

# The setup for user variables.
source_directory  = REF "";
target_directory  = REF "";
header            = REF "";
footer            = REF "";
site_name         = REF "";
site_tagline      = REF "";
site_url          = REF "";
counter_code      = REF "";
copyright         = REF "";

# --

# FIXME Windows:  I need some sort of __SEPARATOR__ variable, which understands "/" on Linux, and "\" on Windows.
separator = REF "\\/";



fun silent_regex_replace_all( rx: String,  replace: String,  string: String ):   String = {
  regex::replace_all  rx  replace  string
    except
    _ =  string;
};



fun silent_regex_replace_first( rx: String,  replace: String,  string: String ):   String = {
  regex::replace_first  rx  replace  string
    except
    _ =  string;
};



fun silent_regex_find_first_group( n: Int,  rx: String,  string: String ):   String = {
  regex::find_first_group  n  rx  string
    except
    _ = {
      if ( *verbose )
        printf "\nsilent_regex_find_first_group():  Warning, found nothing:  '%d' | '%s'\n" n rx;
        printf "--v\n'%s'\n--^\n" string;
      fi;
      "";
    };
};



# TODO:  It would be nice if I could somehow make this code reusable.  It would pick up the variable names from the configuration file itself.  This isn't reasonable to implement right now.  It may not even be possible.
fun read_configuration( filename: String ):   Void = {
  # Read a file by line.
  if ( exists( filename ) == FALSE )
    printf "read_configuration():  File doesn't exist:  '%s'\n" filename;
  else
    stream =  open_for_read( filename );
    # TODO:  Can I read it?  http://mythryl.org/my-Check_File_Readability.html
    # can_read : (Input_Stream , Int) -> Null_Or(Int );
    contents =  read_lines( stream );
    contents =  join "\n" contents;

    # Read in the user variables.
    source_directory :=  silent_regex_find_first_group( 1, "\nsource_directory += +(.*)", contents );
    target_directory :=  silent_regex_find_first_group( 1, "\ntarget_directory += +(.*)", contents );
    header           :=  silent_regex_find_first_group( 1,           "\nheader += +(.*)", contents );
    footer           :=  silent_regex_find_first_group( 1,           "\nfooter += +(.*)", contents );
    site_name        :=  silent_regex_find_first_group( 1,        "\nsite_name += +(.*)", contents );
    site_tagline     :=  silent_regex_find_first_group( 1,     "\nsite_tagline += +(.*)", contents );
    site_url         :=  silent_regex_find_first_group( 1,         "\nsite_url += +(.*)", contents );
    copyright        :=  silent_regex_find_first_group( 1,        "\ncopyright += +(.*)", contents );

    # Because I don't know how to do a multi-line search, I'll cheat.
    contents          =  silent_regex_replace_all( "\n", "\t",  contents     );
    # Searching between {{{ and }}}
    counter_code     :=  silent_regex_find_first_group( 1,     "\tcounter_code += +\\{{3}(.*)\\}{3}", contents );
    counter_code     :=  silent_regex_replace_all( "\t", "\n", *counter_code );
  fi;
};


# ~~~~~~~~~~~~~~ testing

# ~~~~~~~~~~~~~~ general

# ~~~~~~~~~~~~~~ project


# ---
# ---  Actual programming
# ---

# In source directory
#   check if the equivalent file exists in the target directory.
#   If no, re-create it.

# FIXME:  Sanity checking is impossible in this manner, because the initial "if ( winix::etc" is given an invalid directory then it'll just die then and there without passing false.  What the fuck.
# (update) this is probably an issue of trapping an error.  now that I know how, it should be easy enough to do.
# TODO:  Proper sanity-checking.
#        How would I stop script processing if the checking finds a critical error?
fun sanity_check( _: Void ):   Void = {
  if ( winix::file::is_directory( *source_directory ) == FALSE )
    printf "Directory does not exist:  \"%s\"\n"  *source_directory;
    # Make it?
  fi;
};
# sanity_check();


read_configuration( "compiled-website.config" );

rebuild(
  *source_directory + "sandbox.asc",
  *target_directory + "sandbox.html"
);


rebuild(
  *source_directory + "index.asc",
  *target_directory + "index.html"
);

};
