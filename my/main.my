# --
# --  User-serviceable variables
# --

# TODO:  Configuration file.  See TODO.markdown
source_directory =  "/l/projects/compiled-website/git/asc/";
target_directory =  "/l/projects/compiled-website/git/html/";
# -rebuilt.html  will automatically be appended and used, after the search/replace.
header =  "/l/projects/compiled-website/git/my/header.html";
footer =  "/l/projects/compiled-website/git/my/footer.html";

site_name  = "<div class=\"top-t1\">S</div>&nbsp; <div class=\"top-t2\">piral of Hope</div>";
site_tagline =  "<div class=\"top-t3\">Better software is possible.</div>";



# --
# --  Library-candidate functions, general
# --

# TODO:  Figure out libraries / using multiple files for a project.  See `random-mythryl/multi-file-test/`

fun check_directory( string: String ): Bool
    =
{
  directory_list =  dir::entries''( "." );
  # TODO:  Is it necessary to sort dir::entries  ?
  directory_list =  strsort( directory_list );
  current_directory =  head( directory_list );
  string == current_directory;
};
fun test_check_directory( _: Void ): Void
    =
{
  dir =  "/mnt/ssd/mythryl/git/compiled-website/.";
  result =  check_directory( dir );
  if    result
        printf "yes\n";
  else  printf "no\n";
  fi;
};
# test_check_directory();



# TODO:  Only display the current directory's name.  (separate function?)
fun get_current_directory( _: Void ): String
    =
{
  directory_list =  dir::entries''( "." );
  # TODO:  Is it necessary to sort dir::entries  ?
  directory_list =  strsort( directory_list );
  head( directory_list );
};
fun test_get_current_directory( _: Void ): Void
    =
{
  result =  get_current_directory();
  printf "%s\n" result;
};
# test_get_current_directory();


# FIXME:  This needs a better name.
# Removes the path from a string, giving only the filename.
fun get_filename( string: String ): String
    =
{
  # TODO:  I don't need to check for groups here, is there some other regex I should use?
  # FIXME Windows:  I need some sort of __SEPARATOR__ variable, which understands "/" on Linux, and "\" on Windows.
  strcat( regex::find_first_groups_all  ".*\\/(.*)"  string );
};


# FIXME:  This needs a better name.
# Removes the extension(s) from a string.
#   filename.ext     => filename
#   filename.ext.ext => filename
fun remove_extension( filename: String ): String
    =
{
  regex::replace_first  ./\..*$/  ""  filename;
};


# --
# --  Library-candidate functions, project-specific
# --



# ---
# ---  Actual programming
# ---

fun read_print( filename: String ): Void
    =
{
  # Read from a source file.
  # http://mythryl.org/my-File.html
  # http://mythryl.org/my-Read_a_text_file.html
  if    ( exists( filename ) )
        stream =  open_for_read( filename );
        # TODO:  Can I read it?
        # can_read : (Input_Stream , Int) -> Null_Or(Int );
        list =  read_lines( stream );
        apply printf "%s" list;
  fi;
};
fun test_read_print( _: Void ): Void
    =
{
  read_print( "compiled-website.txt" );
};
# test_read_print();


# Write to a target file.
# http://mythryl.org/my-File.html
# http://mythryl.org/my-Write_a_text_file.html
# TODO:  In the docs, what is a "Writer" ?
# I can't realistically convert this into a two-parameter function.
#   Basically I'd have to pass one List of Strings - the filename, and the content.
#   (This is probably not true, but I don't know any better)
#   But why do something as complex as that?  Just use the original simpler code.
fun write_file( _: Void ): Void
    =
{
  filename =  "test-write.txt";

  file = file::open_for_write filename;
  list = [ "line one\n", "line two" ];
  apply fprintf file "%s" list;

  # file::write       ( file, "There is no royal road to mathematics.\n" );
  # fprintf             file  "Mathematics is the %s of the sciences.\n" "queen";
  file::flush         file;
  file::close_output  file;

  # Display its contents.
  if    ( exists( filename ) )
        printf "%s contains:\n--v\n" filename;

        stream =  open_for_read( filename );
        list =  read_lines( stream );
        apply printf "%s" list;
        winix::file::remove_file( filename );
        print "--^\n";
  else
        printf "%s was not created!\n" filename;
  fi;
};
fun test_write_file( _: Void ): Void
    =
{
  write_file();
};
# test_write_file();



# In source directory
#   check if the equivalent file exists in the target directory.
#   if no, re-create it.

# FIXME:  Sanity checking is impossible in this manner, because the initial "if ( winix::etc" is given an invalid directory then it'll just die then and there without passing false.  What the fuck.
# TODO:  Proper sanity-checking.
#        How would I stop script processing if the checking finds a critical error?
fun sanity_check( _: Void ): Void
    =
{
  if    ( winix::file::is_directory( source_directory ) == FALSE )
        printf "Directory does not exist:  \"%s\"\n"  source_directory;
        # Make it?
  fi;
};
# sanity_check();


fun apply_syntax( list: List( String ) ): List( String )
    =
{
  # TODO:  Port my more advanced regular expressions in.
  # TODO:  Review the Ruby code and figure out how I ought to do things like strong-emphasis.
  # TODO:  A feature list.
  # TODO:  Why can't I use [:graph:], [:space:], etc?
  # TODO:  Automated test cases.

  # [\x21-\x7E]  =  [:graph:]  =  printable characters, also doable as [^\s] (not whitespace)
  # [^\32-\151]  =  [:punct:]  =  punctuation
  # \s           =  [:space:]  =  whitespace


  #   -emphasis-
  # TODO:  I'd rather implement /emphasis/ with slashes, but Mythryl 6.1.0 appears to have a bug that's preventing this.
  list = map (
    # These are the characters being matched:     -----.     -----.    -----.
    #                                                  v          v         v
    fn string = regex::replace_all_via_fn  ./(^|.*\s+)\-([^\s]+[^\-][^\s]*)\-([^\32-\151]{0,1}\s+\S*)/ .{
        ( list::nth ( #stringlist, 0 ) )
      + "<em>"
      + ( list::nth ( #stringlist, 1 ) )
      + "</em>"
      + ( list::nth ( #stringlist, 2 ) )
      ;
    }
    string
  ) list;


  #   *strong*
  # FIXME:  Syntax highlighting in Geany will bug out with an escaped asterisk like this.  Notice how the strings are no longer highlighted:
  # (This is old code, just here as an example for the syntax highlighting issue.)
  # list = map ( fn string = regex::replace_all_via_fn  ./()/    .{ "<strong>" + (strcat #stringlist) + "</strong>"; } string ) list;
  # list = map ( fn string = regex::replace_all_via_fn  ./\*(.*)\*/    .{ "<strong>" + (strcat #stringlist) + "</strong>"; } string ) list;
  list = map (
    fn string = regex::replace_all_via_fn  ./(^|.*\s+)\*([^\s]+[^\*][^\s]*)\*([^\32-\151]{0,1}\s+\S*)/ .{
        ( list::nth ( #stringlist, 0 ) )
      + "<strong>"
      + ( list::nth ( #stringlist, 1 ) )
      + "</strong>"
      + ( list::nth ( #stringlist, 2 ) )
      ;
    }
    string
  ) list;


  #   _underlined_
  list = map (
    fn string = regex::replace_all_via_fn  ./(^|.*\s+)\_([^\s]+[^\_][^\s]*)\_([^\32-\151]{0,1}\s+\S*)/ .{
        ( list::nth ( #stringlist, 0 ) )
      + "<u>"
      + ( list::nth ( #stringlist, 1 ) )
      + "</u>"
      + ( list::nth ( #stringlist, 2 ) )
      ;
    }
    string
  ) list;

  list = map ( fn string = regex::replace_all         ./^-{3,4}$/       "<hr>\n"                                           string ) list;

  # TODO:  All of the above does line-processing using map, but I want block-processing that handles multiple lines.

  list;
};



fun rebuild_template( list: List( String ) ): Void
    =
{
  template_filename =  ( list::nth ( list, 0 ) );
  compiling_filename = ( list::nth ( list, 1 ) );
  if    ( exists( template_filename ) == FALSE )
        print ( "File doesn't exist!: " + template_filename );
  else
        # IDEA:  It would be simple to have specific search/replace for a specific file.
        stream =  open_for_read( template_filename );
        # TODO, sanity:  Can I read it?
        # can_read : (Input_Stream , Int) -> Null_Or(Int );
        list =  read_lines( stream );

        page_title =  get_filename( compiling_filename );
        page_title =  remove_extension( page_title );
        # TODO:  Table of Contents
        # FIXME:  Browser, when clicking "Table of Contents", that text seems to wiggle.
        #         (Probably a template issue, possibly unfixable)
        toc =  "<br>TODO";
        # TODO:  RSS
        #        rss-feed-icon-16px-svg.png
        rss =  "";

        # TODO:  Beautify / simplify.  Use a case-regex?
        list =  map ( fn string = regex::replace_all   "<!--SITE NAME-->"     site_name     string ) list;
        list =  map ( fn string = regex::replace_all   "<!--SITE TAGLINE-->"  site_tagline  string ) list;
        list =  map ( fn string = regex::replace_all   "<!--TITLE-->"         page_title    string ) list;
        list =  map ( fn string = regex::replace_all   "<!--TOC-->"           toc           string ) list;
        list =  map ( fn string = regex::replace_all   "<!--RSS-->"           rss           string ) list;

        template_filename =  template_filename + "-rebuilt.html";
        file = file::open_for_write template_filename;
        apply fprintf file "%s" list;
        file::flush         file;
        file::close_output  file;
  fi;
};



fun rebuild( list: List( String ) ): Void
    =
{
  compiling_filename = ( list::nth ( list, 0 ) );
  target_filename =    ( list::nth ( list, 1 ) );
  
  if    ( exists( compiling_filename ) == FALSE )
        print ( "File doesn't exist!: " + compiling_filename );
  else
        rebuild_template( [ header, compiling_filename ] );
        rebuild_template( [ footer, compiling_filename ] );

        stream =  open_for_read( header + "-rebuilt.html" );
        content_list =  read_lines( stream );

        stream =  open_for_read( compiling_filename );
        content_list =  content_list @ apply_syntax( read_lines( stream ) );

        stream =  open_for_read( footer + "-rebuilt.html" );
        content_list =  content_list @ read_lines( stream );

        f =  file::open_for_write  target_filename;
        apply fprintf       f  "%s"  content_list;
        file::flush         f;
        file::close_output  f;
  fi;
};



rebuild( [
  source_directory + "sandbox.asc",
  target_directory + "sandbox.html"
] );


rebuild( [
  source_directory + "../index.asc",
  target_directory + "../index.html"
] );
