# --
# --  User-serviceable variables
# --

# TODO:  I have a major looming issue with regular expression search/replace
# match for xx.*xx and replace with xxyyxx
# I would expect xxzzxxzzxx => xxyyxxyyxx but instead I get xxyyxxzzxx (the second xxzzxx is not matched)


# TODO:  Configuration file.  See TODO.markdown
source_directory =  "/l/projects/compiled-website/git/asc/";
target_directory =  "/l/projects/compiled-website/git/html/";
# -rebuilt.html  will automatically be appended and used, after the search/replace.
header =  "/l/projects/compiled-website/git/my/header.html";
footer =  "/l/projects/compiled-website/git/my/footer.html";

site_name  = "<div class=\"top-t1\">S</div>&nbsp; <div class=\"top-t2\">piral of Hope</div>";
site_tagline =  "<div class=\"top-t3\">Better software is possible.</div>";



# --
# --  Library-candidate functions, general
# --

# TODO:  Figure out libraries / using multiple files for a project.  See `random-mythryl/multi-file-test/`

fun check_directory( string: String ): Bool
    =
{
  # See also http://mythryl.org/my-Get_current_directory.html
  # getcwd ();

  directory_list =  dir::entries''( "." );
  # TODO:  Is it necessary to sort dir::entries  ?
  directory_list =  strsort( directory_list );
  current_directory =  head( directory_list );
  string == current_directory;
};
fun test_check_directory( _: Void ): Void
    =
{
  dir =  "/mnt/ssd/mythryl/git/compiled-website/.";
  result =  check_directory( dir );
  if    result
        printf "yes\n";
  else  printf "no\n";
  fi;
};
# test_check_directory();



# TODO:  Only display the current directory's name.  (separate function?)
fun get_current_directory( _: Void ): String
    =
{
  directory_list =  dir::entries''( "." );
  # TODO:  Is it necessary to sort dir::entries  ?
  directory_list =  strsort( directory_list );
  head( directory_list );
};
fun test_get_current_directory( _: Void ): Void
    =
{
  result =  get_current_directory();
  printf "%s\n" result;
};
# test_get_current_directory();


# FIXME:  This needs a better name.
# Removes the path from a string, giving only the filename.
fun get_filename( string: String ): String
    =
{
  # TODO:  I don't need to check for groups here, is there some other regex I should use?
  # FIXME Windows:  I need some sort of __SEPARATOR__ variable, which understands "/" on Linux, and "\" on Windows.
  strcat( regex::find_first_groups_all  ".*\\/(.*)"  string );
};



# FIXME:  RENAME
# Removes the extension(s) from a string.
#   filename.ext     => filename
#   filename.ext.ext => filename
fun remove_extension( filename: String ): String
    =
{
  regex::replace_first  ./\..*$/  ""  filename;
};



fun string_to_list( string: String ): List( String )
    =
{
  fields .{ #c == '\n'; } string;
};



fun string_multiplier( list: List( String ) ): String
    =
{
  string =  list::nth( list, 0 );
  n =  list::nth( list, 1 );
  # string -> int
  n =  atoi n;

 cat( list::tabulate( n, fn _ = string ) );
};
# print ( string_multiplier( [ "foo", "2" ] ) );



# TODO:  Throw errors
# TODO:  Tallying:  Number of tests, passes and fails.  Time spent processing.
fun assert_equal( list: List( String ) ): Bool
    =
{
  expected =  list::nth( list, 0 );
  result   =  list::nth( list, 1 );
  if
    ( expected == result )
#     printf "yes\n";
    TRUE;
  else
    print "\n  ** FAIL **\n";
    print ( list::nth( list, 1 ) );
    print "\n  =>\n";
    print ( list::nth( list, 0 ) );
    print "\n";
    FALSE;
  fi;
};



fun remove_character( list: List( String ) ): String
    =
{
  character =  list::nth( list, 0 );
  string =  list::nth( list, 1 );

  my tmp =  REF "";
  n =  string::length( string );
  for ( i = 0; i < n; ++i ) {
    pos =  explode string;
    pos =  list::nth( pos, i );
    pos =  char::to_string( pos );
    if ( pos != character )
      tmp :=  *tmp + pos;
    fi;
  };
  *tmp;
};
# string =  "test\ntwo";
# print ( remove_character( [ "\\n", string ] ) );


fun is_even( i: Int ): Bool
    =
{
  if ( ( i % 2 ) == 0 )
    TRUE;
  else
    FALSE;
  fi;
};
# i =  2;
# if ( is_even( i ) )
#   printf "%d is even\n" i;
# fi;


fun is_odd( i: Int ): Bool
    =
{
  if ( ( i % 2 ) == 0 )
    FALSE;
  else
    TRUE;
  fi;
};
# i =  1;
# if ( is_odd( i ) )
#   printf "%d is odd\n" i;
# fi;



# --
# --  Library-candidate functions, project-specific
# --



# ---
# ---  Actual programming
# ---

fun read_print( filename: String ): Void
    =
{
  # Read from a source file.
  # http://mythryl.org/my-File.html
  # http://mythryl.org/my-Read_a_text_file.html
  if    ( exists( filename ) )
        stream =  open_for_read( filename );
        # TODO:  Can I read it?  http://mythryl.org/my-Check_File_Readability.html
        # can_read : (Input_Stream , Int) -> Null_Or(Int );
        list =  read_lines( stream );
        apply printf "%s" list;
  fi;
};
fun test_read_print( _: Void ): Void
    =
{
  read_print( "compiled-website.txt" );
};
# test_read_print();


# Write to a target file.
# http://mythryl.org/my-File.html
# http://mythryl.org/my-Write_a_text_file.html
# TODO:  In the docs, what is a "Writer" ?
# I can't realistically convert this into a two-parameter function.
#   Basically I'd have to pass one List of Strings - the filename, and the content.
#   (This is probably not true, but I don't know any better)
#   But why do something as complex as that?  Just use the original simpler code.
fun write_file( _: Void ): Void
    =
{
  filename =  "test-write.txt";

  file = file::open_for_write filename;
  list = [ "line one\n", "line two" ];
  apply fprintf file "%s" list;

  # file::write       ( file, "There is no royal road to mathematics.\n" );
  # fprintf             file  "Mathematics is the %s of the sciences.\n" "queen";
  file::flush         file;
  file::close_output  file;

  # Display its contents.
  if    ( exists( filename ) )
        printf "%s contains:\n--v\n" filename;

        stream =  open_for_read( filename );
        list =  read_lines( stream );
        apply printf "%s" list;
        winix::file::remove_file( filename );
        print "--^\n";
  else
        printf "%s was not created!\n" filename;
  fi;
};
fun test_write_file( _: Void ): Void
    =
{
  write_file();
};
# test_write_file();



# In source directory
#   check if the equivalent file exists in the target directory.
#   if no, re-create it.

# FIXME:  Sanity checking is impossible in this manner, because the initial "if ( winix::etc" is given an invalid directory then it'll just die then and there without passing false.  What the fuck.
# TODO:  Proper sanity-checking.
#        How would I stop script processing if the checking finds a critical error?
fun sanity_check( _: Void ): Void
    =
{
  if    ( winix::file::is_directory( source_directory ) == FALSE )
        printf "Directory does not exist:  \"%s\"\n"  source_directory;
        # Make it?
  fi;
};
# sanity_check();


fun markup( string: String ): String
    =
{
  # TODO:  RENAME
  fun markup_needs_a_name( list: List( String ) ): String
      =
  {
    string        =  list::nth( list, 0 );
    rx_left       =  list::nth( list, 1 );
    rx_right      =  list::nth( list, 2 );
    replace_left  =  list::nth( list, 3 );
    replace_right =  list::nth( list, 4 );

    fun punctuation_regex( list: List( String ) ): String
        =
    {
      rx_left  =  list::nth( list, 0 );
      rx_right =  list::nth( list, 1 );

      # TODO:  Why can't I directly use [:graph:], [:space:], etc?
      graph =  "[\\x21-\\x7E]";   # [\x21-\x7E]  =  [:graph:]  =  printable characters, also doable as [^\s] (not whitespace)
      punct =  "[^\\32-\\151]";   # [^\32-\151]  =  [:punct:]  =  punctuation
      space =  "\\s";             # \s           =  [:space:]  =  whitespace

      left =
          "^"
        + "|" + space
        ;
      left =
          left
        + "|" + left + punct
        + "|" + left + "\\("
        + "|" + left + "--"
      ;

      right =
          "$"
        + "|" + space
        ;
      right =
          right
        + "|" + punct + right
        + "|" + "\\)" + right
        + "|" + "--"  + right
      ;
      right =
          right
        + "|" + "s"  + right
        + "|" + "es" + right
        + "|" + "ed" + right
      ;
      "(" + left + ")(" + rx_left + ")(.*)(" + rx_right + ")(" + right + ")";
    };

    # TODO:    string =  split_string_html( string );

    rx = punctuation_regex( [ rx_left, rx_right ] );
    string =  regex::replace_all_via_fn  rx .{
        ( list::nth( #stringlist, 0 ) )
      + replace_left
      + ( list::nth( #stringlist, 2 ) )
      + replace_right
      + ( list::nth( #stringlist, 4 ) )
      ;
    } string;
    string;
  };



  fun markup_horizontal_rules( string: String ): String
      =
  {
    # With an empty space above and below.
    fun markup_horizontal_rules_long( string: String ): String
        =
    {
      regex::replace_all  ./\n{2}\-{3,}\n{2}/  "\n<hr class=\"long\">\n" string;
    };

    fun markup_horizontal_rules_short( string: String ): String
        =
    {
      # (with content above)
      string =  regex::replace_all_via_fn  ./([^\n])\n-{3,}\n{2}/ .{ strcat( #stringlist ) + "<hr class=\"small\">\n"; } string;
      # (with content below)
      string =  regex::replace_all_via_fn  ./\n{2}-{3,}\n([^\n])/ .{ "\n<hr class=\"small\">" + strcat( #stringlist ); } string;
      string;
    };

    string =  markup_horizontal_rules_long ( string );
    string =  markup_horizontal_rules_short( string );
    string;
  };



  fun markup_paragraphs( string: String ): String
      =
  {
    # \n\n  =  Paragraph
    regex::replace_all_via_fn  ./(\n{2,})/ .{
      n =  strlen( strcat( #stringlist ) );
      n =  int::to_string n;
      string_multiplier( [ "\n<br />", n ] );
    } string;
  };


  string =  markup_needs_a_name( [ string, "\\/", "\\/", "<em>"    , "</em>"     ] );
  string =  markup_needs_a_name( [ string, "-"  , "-"  , "<del>"   , "</del>"    ] );
  string =  markup_needs_a_name( [ string, "\\*", "\\*", "<strong>", "</strong>" ] );
  string =  markup_needs_a_name( [ string, "_"  , "_"  , "<u>"     , "</u>"      ] );
  string =  markup_horizontal_rules( string );
  string =  markup_paragraphs( string );
  string;
};



fun rebuild_template( list: List( String ) ): Void
    =
{
  template_filename =  ( list::nth( list, 0 ) );
  compiling_filename = ( list::nth( list, 1 ) );
  if    ( exists( template_filename ) == FALSE )
        print ( "File doesn't exist!: " + template_filename );
  else
        # IDEA:  It would be simple to have specific search/replace for a specific file.
        stream =  open_for_read( template_filename );
        # TODO sanity:  Can I read it?  http://mythryl.org/my-Check_File_Readability.html
        # can_read : (Input_Stream , Int) -> Null_Or(Int );
        list =  read_lines( stream );

        page_title =  get_filename( compiling_filename );
        page_title =  remove_extension( page_title );
        # TODO:  Table of Contents
        # FIXME:  Browser, when clicking "Table of Contents", that text seems to wiggle.
        #         (Probably a template issue, possibly unfixable)
        toc =  "<br>TO DO";
        # TODO:  RSS
        #        rss-feed-icon-16px-svg.png
        rss =  "";

        # TODO:  Beautify / simplify.  Use a case-regex?
        list =  map ( fn string = regex::replace_all   "<!--SITE NAME-->"     site_name     string ) list;
        list =  map ( fn string = regex::replace_all   "<!--SITE TAGLINE-->"  site_tagline  string ) list;
        list =  map ( fn string = regex::replace_all   "<!--TITLE-->"         page_title    string ) list;
        list =  map ( fn string = regex::replace_all   "<!--TOC-->"           toc           string ) list;
        list =  map ( fn string = regex::replace_all   "<!--RSS-->"           rss           string ) list;

        template_filename =  template_filename + "-rebuilt.html";
        file = file::open_for_write template_filename;
        apply fprintf file "%s" list;
        file::flush         file;
        file::close_output  file;
  fi;
};



# TODO:  Think up a better name.
fun post_processing( content_string: String ): String
    =
{
  fun post_processing_redirect( content_string: String ): String
      =
  {
    match =  "<!--REDIRECT (.*)-->";
    if   ( ( content_string =~ match ) == FALSE )
      content_string;
    else
      page_name = regex::find_first_group 1  match  content_string;
      content_string =  regex::replace_all  match  ( "<p>Redirecting to " + page_name + " ...</p>" )  content_string;
      replace =  "<head><meta http-equiv=\"refresh\" content=\"2;url=" + page_name + "\">";
      content_string =  regex::replace_first  "<head>"  replace  content_string;
      content_string;
    fi;
  };

  content_string = post_processing_redirect( content_string );

  content_string;
};



fun rebuild( list: List( String ) ): Void
    =
{
  compiling_filename = ( list::nth( list, 0 ) );
  target_filename =    ( list::nth( list, 1 ) );
  
  if    ( exists( compiling_filename ) == FALSE )
        print ( "File doesn't exist!: " + compiling_filename );
  else
        rebuild_template( [ header, compiling_filename ] );
        rebuild_template( [ footer, compiling_filename ] );

        content_string =                                 strcat( lines( header + "-rebuilt.html" ) );
        content_string =  content_string + markup( strcat( lines( compiling_filename ) ) );
        content_string =  content_string +               strcat( lines( footer + "-rebuilt.html" ) );
        content_string =  post_processing( content_string );

        f =  file::open_for_write  target_filename;
        file::write       ( f, content_string );
        file::flush         f;
        file::close_output  f;
  fi;
};



rebuild( [
  source_directory + "sandbox.asc",
  target_directory + "sandbox.html"
] );


# rebuild( [
#   source_directory + "../index.asc",
#   target_directory + "../index.html"
# ] );




# --
# --  Test cases
# --  (more or less)
# TODO:  Absorb the test cases from the Ruby project.


string =  "test";
expected =  "test";
result =  markup( string );
assert_equal( [ expected, result ] );

string =  "\n/emphasis/\n";
expected =  "\n<em>emphasis</em>\n";
# FIXME:  Markup is chopping off the final \n.
expected =  "\n<em>emphasis</em>";
result =  markup( string );
assert_equal( [ expected, result ] );

string =  "/emphasis/";
expected =  "<em>emphasis</em>";
result =  markup( string );
assert_equal( [ expected, result ] );

# Given a list of strings
# Change a specified element
fun modify_list_element( list: List( String ) ): List( String )
    =
{
  modify_element_number =  atoi ( head( list ) );
  list                  =         tail( list );
  new_element_text      =         head( list );
  list                  =         tail( list );

  i =       REF -1;
  result =  REF [];
  foreach list .{
    i :=  *i + 1;
    if    ( *i == modify_element_number )
          result := *result @ [ new_element_text ];
    else
          result := *result @ [ #e ];
    fi;
  };
  *result;
};
list =  [ "This ", "is ", "a ", "test." ];
parameters =  "1" ! "was " ! list;
result =  modify_list_element( parameters );
apply printf "%s" result;
# =>
# This was a test.


# ~~~~~~~~~~~~~~
# TODO TODO TODO
# ~~~~~~~~~~~~~~

# Take a string, and break it into a list of strings.  That list of strings is odd-even, where odd is of one type and even is of another type.
# The idea is to break a string down so that a function can be applied to specific parts of it.
# For example, I want to apply markup, but not to text inside of blocks of html.
fun block_matcher( string: String ): List( String )
    =
{
  fun block_matcher_bool( string: String ): Bool
      =
  {
#     if ( regex )
#       TRUE;
#     else;
#       FALSE;
#     fi;
    
    TRUE;
  };


  newly_matched =  REF FALSE;
  return =  REF [ "" ];
  working =  REF "";
  i = REF -1;
  list =  string_to_list( string );
  # Iterate through the list of strings.
  foreach list .{
    tmp = #e;
    i := *i + 1;

    # For each line, refer to a function which gives a Bool result.
    if  ( block_matcher_bool( #e ) == TRUE )
      # Based on the Bool, either append to a working string or append to the list and begin an empty working string.
      if ( *newly_matched == TRUE )
        # append working onto the last element of return
        print "";
      fi;
    fi;

  };

# printf "%s\n" ( strcat( *odd ) );
# printf "%s\n" ( strcat( *even ) );





  # Placeholder
  [ "no", "yes", "no" ];
};





# TODO:  create  assert_equal_lists()
fun assert_equal_lists( list: List( List ( String ) ) ): Bool
    =
{
  expected =  list::nth( list, 0 );
  result   =  list::nth( list, 1 );

# TODO
# Compare list::length()

#   if
#     ( expected == result )
#     TRUE;
#   else
#     print "\n  ** FAIL **\n";
#     print ( list::nth( list, 1 ) );
#     print "\n  =>\n";
#     print ( list::nth( list, 0 ) );
#     print "\n";
#     FALSE;
#   fi;

  # Placeholder
  FALSE;
};

string =  "xtestx\nytesty\n";
expected =  [ "xtestx\n", "ytesty\n" ];
result =  string_to_list( string );
# assert_equal_lists( [ expected, result ] );

# expected = "xTESTx\nytesty\n";
# result = apply_thingemybob( result );
# assert_equal_lists( [ expected, result ] );



string =  "xtestx\nytesty\n";
l =  block_matcher( string );
# print ( cat( l ) );
