package general {
# --
# -- Library-candidate functions, general
# --

fun reveal_unprintable_characters( string ) = {
    #  Spaces
  string = general::silent_regex_replace_all( "\\ ", "·", string );
    #  Newlines
  string = general::silent_regex_replace_all( "\\n", "↵\n", string );
    #  Tabs
  string = general::silent_regex_replace_all( "\\t", "»\n", string );
    #
  string;
};



fun two_lists_of_strings_to_columnized_string( list_one, list_two ) = {
  string_one =  general::list_of_strings_to_columnized_string( list_one, "'", "'" );
  string_two =  general::list_of_strings_to_columnized_string( list_two, "'", "'" );
  separator =  "   ";
  general::two_strings_to_columnized_string( string_one, string_two, separator );
};
fun test_two_lists_of_strings_to_columnized_string = {
  list_one =  [ "one", "two", "three" ];
  list_two =  [ "four", "five", "six" ];
  # 'one'     'four'
  # 'two'     'five'
  # 'three'   'six'
  # Odd bug, it's showing up with an extra space at the very end, like so:
  # I'm not in the mood to hunt this crap down.  I probably won't be in the mood later either.  Sigh.
  expected = "'one'     'four'\n'two'     'five'\n'three'   'six' \n";
  
  expected = "'one'     'four'\n'two'     'five'\n'three'   'six'\n";
  result =  general::two_lists_of_strings_to_columnized_string( list_one, list_two );
  test::assert_strings_are_equal( expected, result );
};
# test_two_lists_of_strings_to_columnized_string();



fun two_strings_to_columnized_string( string_one, string_two, separator ) = {
  # FIXME:  Remember that  string_to_list()  is bugged.  It removes consecutive \n's
  list_one =  general::string_to_list( string_one );
  list_two =  general::string_to_list( string_two );

  # Ensure the two lists are the same length.
  pad_string_list =  general::pad_string_list( list_one, list_two );
  list_one =  list::nth( pad_string_list, 0 );
  list_two =  list::nth( pad_string_list, 1 );


  result =  REF "";
  i      =  REF -1;
  foreach list_one .{
    i :=  *i + 1;
    one  =  REF "";
    one :=  string::chomp( #e );
    if ( *one == "" )
      n =  general::longest_string_in_a_list_of_strings( list_one );
      # I'm not sure why I need to do this, but whatever.
      n =  n - 1;
      one :=  string_multiplier( " ", n );
    fi;
    two =  list::nth( list_two, *i );
    result :=
        *result
      + *one
      + separator
      + two
      ;
  };

  *result;
};
# TODO:  An assertion?
fun test_two_strings_to_columnized_string = {
  string_one =  "one\ntwo\n";
  string_two =  "three\n";
  result =  general::two_strings_to_columnized_string( string_one, string_two, "   " );
  print result;

  string_one =  "one\ntwo";
  string_two =  "three\nfour\nfive";
  result =  general::two_strings_to_columnized_string( string_one, string_two, "   " );
  print result;
};
# test_two_strings_to_columnized_string();


fun list_of_strings_to_columnized_string( list, prepended_text, appended_text ) = {
  column_width =  general::longest_string_in_a_list_of_strings( list );
  column_width =  column_width + string::length( prepended_text );
  column_width =  column_width + string::length( appended_text  );

  result =  REF "";
  foreach list .{
    n =
        column_width
      - string::length( #e )
      - string::length( prepended_text )
      - string::length( appended_text )
      ;
    spaces =  general::string_multiplier( " ", n );
    result :=
        *result
      + prepended_text
      + #e
      + appended_text
      + spaces
      + "\n"
      ;
  };

  *result;
};
# TODO: proper assertions.
fun test_list_of_strings_to_columnized_string = {
  list = [ "one", "two", "three" ];
  prepended_text =  "'";
  appended_text  =  "'";

  result =  general::list_of_strings_to_columnized_string( list, prepended_text, appended_text );
  print result;
};
# test_list_of_strings_to_columnized_string();



fun string_multiplier( string, n ) = {
  if   ( n <  0 )
    # TODO:  Throw an error.
    printf "You want to multiply a string by a negative number? :  %d\n"  n;
    "";
  elif ( n == 0 )
    "";
  else
    cat( list::tabulate( n, fn _ = string ) );
  fi;
};
fun test_string_multiplier = {
  string   = "foo";
  n        = 2;
  expected = "foofoo";
  result = ( general::string_multiplier( string, n ) );
  test::assert_strings_are_equal( expected, result );

  string   = "foo";
  n        = 0;
  expected = "";
  result = ( general::string_multiplier( string, n ) );
  test::assert_strings_are_equal( expected, result );

  string   = "foo";
  n        = -1;
  expected = "";
#   result = ( general::string_multiplier( string, n ) );
#   test::assert_strings_are_inequal( expected, result );

  string   = "foo";
  n        = 2;
  expected = "FAIL TEST";
  result = ( general::string_multiplier( string, n ) );
  test::assert_strings_are_inequal( expected, result );
};
# test_string_multiplier();



fun silent_regex_replace_all( rx: String,  replace: String,  string: String ):   String = {
  regex::replace_all  rx  replace  string
    except
    _ =  string;
};



fun silent_regex_replace_first( rx: String,  replace: String,  string: String ):   String = {
  regex::replace_first  rx  replace  string
    except
    _ =  string;
};



fun silent_regex_find_first_group( n: Int,  rx: String,  string: String ):   String = {
  regex::find_first_group  n  rx  string
    except
    _ = {
      if ( *verbose )
        printf "\nsilent_regex_find_first_group():  Warning, found nothing:  '%d' | '%s'\n" n rx;
        printf "--v\n'%s'\n--^\n" string;
      fi;
      "";
    };
};



fun check_directory( string ) = {
  # See also http://mythryl.org/my-Get_current_directory.html
  # getcwd ();

  directory_list =  dir::entries''( "." );
  # TODO:  Is it necessary to sort dir::entries  ?
  directory_list =  strsort( directory_list );
  current_directory =  head( directory_list );
  string == current_directory;
};
fun test_check_directory( string ) = {
  result =  general::check_directory( string );
  expected = TRUE;
  test::assert_bools_are_equal( expected, result );
};
# string =  "/mnt/ssd/mythryl/git/compiled-website/git/my/.";
# test_check_directory( string );



# TODO:  Only display the current directory's name.  (separate function?)
fun get_current_directory = {
  directory_list =  dir::entries''( "." );
  # TODO:  Is it necessary to sort dir::entries  ?
  directory_list =  strsort( directory_list );
  head( directory_list );
};
# TODO:  A proper assertion.
fun test_get_current_directory = {
  result =  general::get_current_directory();
  printf "%s\n" result;
};
# test_get_current_directory();



# FIXME:  This needs a better name.
# Removes the path from a string, giving only the filename.
fun get_filename( string: String ):   String = {
  general::silent_regex_replace_all( "(.*)" + *separator, "", string );
};
fun test_get_filename = {
  string =  "/foo/bar/baz/filename.ext";
  expected =             "filename.ext";
  result = general::get_filename( string );
  test::assert_strings_are_equal( expected, result );
  # TODO:  Additional testing.
};
# test_get_filename();



# FIXME:  RENAME
# Removes the extension(s) from a string.
#   filename.ext     => filename
#   filename.ext.ext => filename
fun remove_extension( filename ) = {
  general::silent_regex_replace_first( ./\..*$/, "", filename );
};
fun test_remove_extension( _: Void ):   Bool = {
  string   = "filename.ext";
  expected = "filename";
  result = general::remove_extension( string );
  test::assert_strings_are_equal( expected, result );

  # TODO:  Additional testing.
};
# test_remove_extension();



# TODO:  Replace this with something easier to understand, using the standard take_n, drop_n and whatnot.
fun replace_nth_string( n, replacement, list ) = {
    i =       REF -1;
    result =  REF [];

    foreach list .{
      i :=  *i + 1;
      if ( *i == n )
        result := *result @ [ replacement ];
      else
        result := *result @ [ #e ];
      fi;
    };

    *result;
};
# TODO:  fun test_replace_nth_string( foo ):   bar = {}
# list =  [ "This ", "is ", "a ", "test.\n" ]; 
# result =  replace_nth_string( 1, "was ", list );
# apply  printf "%s" result; 



# string_to_list() ideas
# TODO?:  Consider the existing string_to_list, maybe it can do what I want.
#         http://mythryl.org/my-String_To_List.html
#         String_To_List { first, between, last, string };

# Shit, this is way too complex to bother finishing.  There has to be something like this already available..
# I wonder if there is an "apply" or "map" usable on strings, to treat it as a list of characters.
#   match_character = "\n";
#   result =  REF [];
#   list =  explode( "abc\ndef\n" );
# Ugh, I'd have to turn the list of chars into a list of strings.
#   list =  reverse( list );
#   foreach list .{
#     # Build `result` based on if the character matches.
#     IF ( #e == match_character )
#     else
#     fi;
#     printf "%c\n" #e;
#   };
# apply  printf "'%s'\n" *result;

fun string_to_list( string ) = {
  result =  REF [];

  if ( ( string =~ "\n" ) == FALSE )
    result :=  [ string ];
  else
    list =  tokens .{ #c == '\n'; } string;
    foreach list .{
      result :=  *result @ [ #e + "\n" ];
    };
  fi;

  *result;
};
fun test_string_to_list = {
  # Simple
  string =  "foo";
  expected =  [ "foo" ];
  result =  general::string_to_list( string );
  test::assert_lists_of_strings_are_equal( expected, result );

  # Simple
  string =  "foo\n";
  expected =  [ "foo\n" ];
  result =  general::string_to_list( string );
  test::assert_lists_of_strings_are_equal( expected, result );

  string =  "HERE\nytesty\n";
  expected =  [ "HERE\n", "ytesty\n" ];
  result =  general::string_to_list( string );
  test::assert_lists_of_strings_are_equal( expected, result );
};
# test_string_to_list();



# Append blank elements to the shorter list to make it the same length.
# TODO:  Can I make this type-agnostic.
fun pad_string_list( list_one, list_two ) = {
  list_one =  REF list_one;
  list_two =  REF list_two;
  # Given two lists.
  # Determine which is longer.
  # Determine how much longer it is.
  l1 =  list::length( *list_one );
  l2 =  list::length( *list_two );
  if   ( l1 >  l2 )
    ++l2;
    foreach ( l2..l1 ) .{
      throwaway =  #i;
      # TODO:  If I wanted to make this type-agnostic, I'd have to learn how to append a blank element.
      list_two :=  *list_two @ [ "" ];
    };
  elif ( l1 <  l2 )
    ++l1;
    foreach ( l1..l2 ) .{
      throwaway =  #i;
      list_one :=  *list_one @ [ "" ];
    };
  fi;

  [ *list_one, *list_two ];
};
fun test_pad_string_list = {
  list_one =  [ "one" ];
  list_two =  [ "one", "two" ];
  pad_string_list =  general::pad_string_list( list_one, list_two );
  list_one =  list::nth( pad_string_list, 0 );
  list_two =  list::nth( pad_string_list, 1 );

  expected =  [ "one", "" ];
  result =  list_one;
  test::assert_lists_of_strings_are_equal( expected, result );
};
# test_pad_string_list();



# TODO:  Homework for the reader.
#        1) Implement a function which reports the position of the longest string.
#        2) What if multiple strings are the same length?
#        2a) Implement another function to report how many n-length strings there are.
#        2b) Implement another function to report the positions of all n-length strings.
fun longest_string_in_a_list_of_strings( list ) = {
  n =  REF 0;
  foreach list .{
    len =  string::length( #e );
    if ( len > *n ) n :=  len; fi;
  };
  *n;
};
fun test_longest_string_in_a_list_of_strings = {
  list =  [ "one", "two", "three" ];
  expected =  5;   # "three" is five characters long.
  result =  general::longest_string_in_a_list_of_strings( list );
  test::assert_ints_are_equal( expected, result );
};
# test_longest_string_in_a_list_of_strings();



fun read_print( filename ) = {
  # Read from a source file.
  # http://mythryl.org/my-File.html
  # http://mythryl.org/my-Read_a_text_file.html
  if ( exists( filename ) )
    # file::  ?
    stream =  open_for_read( filename );
    # TODO:  Can I read it?  http://mythryl.org/my-Check_File_Readability.html
    # can_read : (Input_Stream , Int) -> Null_Or(Int );
    # file::  ?
    list =  read_lines( stream );
    apply printf "%s" list;
  fi;
};
# TODO:  A proper assertion.
# But to do that I'd have to touch the disk, which is stupid for tests to do.
# I ought to make this just reading a file into a string, and printing can be something like:
#   print ( read_file( filename ) );
fun test_read_print( _: Void ):   Void = {
  general::read_print( "compiled-website.txt" );
};
# test_read_print();


# Write to a target file.
# http://mythryl.org/my-File.html
# http://mythryl.org/my-Write_a_text_file.html
# TODO:  In the docs, what is a "Writer" ?
# I can't realistically convert this into a two-parameter function.
#   Basically I'd have to pass one List of Strings - the filename, and the content.
#   (This is probably not true, but I don't know any better)
#   But why do something as complex as that?  Just use the original simpler code.
fun write_file = {
  filename =  "test-write.txt";

  file = file::open_for_write filename;
  list = [ "line one\n", "line two" ];
  apply fprintf file "%s" list;

  # file::write       ( file, "There is no royal road to mathematics.\n" );
  # fprintf             file  "Mathematics is the %s of the sciences.\n" "queen";
  file::flush         file;
  file::close_output  file;

  # Display its contents.
  if ( exists( filename ) )
    printf "%s contains:\n--v\n" filename;

    # file::  ?
    stream =  open_for_read( filename );
    # file::  ?
    list =  read_lines( stream );
    apply printf "%s" list;
    winix::file::remove_file( filename );
    print "--^\n";
  else
    printf "%s was not created!\n" filename;
  fi;
};
# TODO:  A proper assertion?  That would touch the disk, which is a no-no.
fun test_write_file( _: Void ):   Void = {
  general::write_file();
};
# test_write_file();




fun test_all_tests = {
  test_check_directory();

  # TODO:  A proper assertion.
#   test_get_current_directory();

  # TODO:  A proper assertion.
#   test_get_current_directory();

  test_get_filename();
  test_remove_extension();

  test_string_to_list();
  test_pad_string_list();
  test_longest_string_in_a_list_of_strings();

  # TODO:  A proper assertion.
#   test_read_print();

  # TODO:  A proper assertion.
#   test_write_file();
};

};
