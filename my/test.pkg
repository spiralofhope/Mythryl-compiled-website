package test {
# --
# -- Library-candidate functions, testing-related
# --




# TODO:  should testing be able to throw errors?
# TODO:  Tallying:  Number of tests, passes and fails.  Time spent processing.
# TODO:  Numbers, stats, etc.
# TODO:  comparing Lists of Ints, etc?  I can't re-use test_assert_lists_of_strings_are_equal() if printf needs %s to display contents.  How do I deal with this?
# TODO:  Make an assert_not() which will flip TRUE=>FALSE and FALSE=>TRUE.  Then leverage that with a 'not' for each assert_foo test function.
#        For example, make assert_strings_are_not_equal() but leverage the existing assert_strings_are_equal() and pass it through assert_not() somehow or other.  You can do it.

fun assert_not( bool: Bool ):   Bool = {
  if ( bool == TRUE )
    FALSE;
  else
    TRUE;
  fi;
};



# TODO:  Make a general "assert_equal() which can handle all types.
fun assert_strings( type, one, two ) = {
  if   ( type == TRUE   and  one == two )
    TRUE;
  elif ( type == FALSE  and  one != two )
    TRUE;
  else
    one =  reveal_unprintable_characters( one );
    two =  reveal_unprintable_characters( two );
    print "\n  * assert_strings: ";
    if     ( type == TRUE )
      print "Asserted TRUE, got FALSE.\n";
      printf "%s\n => %s\n" one two;
    else # ( type != TRUE )
      print "Asserted FALSE, got TRUE.\n";
      printf "%s\n" one;
    fi;
    FALSE;
  fi;
};
fun assert_strings_are_equal( expected, result ) = {
  test::assert_strings( TRUE, expected, result );
};
fun assert_strings_are_inequal( expected, result ) = {
  test::assert_strings( FALSE, expected, result );
};
fun test_assert_strings = {
  test::assert_strings_are_equal( "", "" );
  test::assert_strings_are_inequal( "one", "two" );
};
# test_assert_strings();



fun assert_lists_of_strings( type, list_one, list_two ) = {

  result =  REF TRUE;

  fun assert_lists_of_strings_check_content( type: Bool,  list_one: List( String ),  list_two: List( String ) ):   Bool = {
    i =  REF -1;
    return__assert_lists_of_strings_check_content =  REF TRUE;
    foreach list_one .{
      throwaway =  #e;
      i :=  *i + 1;
      one =  list::nth( list_one, *i );
      two =  list::nth( list_two, *i );
      test::assert_strings( type, one, two );
    };
    if     ( type == TRUE   and  *return__assert_lists_of_strings_check_content == TRUE  )
      TRUE;
    elif   ( type == FALSE  and  *return__assert_lists_of_strings_check_content == FALSE )
      TRUE;
    else
      FALSE;
    fi;
  };


  if     ( type == TRUE )
    if     ( list::length( list_one ) == list::length( list_two ) )
      result :=  assert_lists_of_strings_check_content( type, list_one, list_two );
    else # ( list::length( list_one ) != list::length( list_two ) )
      tmp =  general::two_lists_of_strings_to_columnized_string( list_one, list_two );
      tmp =  general::reveal_unprintable_characters( tmp );
      print "  # FAIL - Lists are different lengths.\n";
      result :=  FALSE;
    fi;
  else # ( type != TRUE )
    if     ( list::length( list_one ) == list::length( list_two ) )
      result :=  assert_lists_of_strings_check_content( type, list_one, list_two );
    else # ( list::length( list_one ) != list::length( list_two ) )
      result :=  TRUE;
    fi;
  fi;
  *result; 
};
fun assert_lists_of_strings_are_equal( list_one, list_two ) = {
  test::assert_lists_of_strings( TRUE, list_one, list_two );
};
fun assert_lists_of_strings_are_inequal( list_one, list_two ) = {
  test::assert_lists_of_strings( FALSE, list_one, list_two );
};



fun assert_ints( type, one, two ) = {
  if   ( type == TRUE  and one == two )
    TRUE;
  elif ( type == FALSE and one != two )
    TRUE;
  else
    printf "  # FAIL:  expected %d result %d\n"  one two;
    FALSE;
  fi;
};

fun assert_ints_are_equal( one, two ) = {
  test::assert_ints( TRUE, one, two );
};
fun assert_ints_are_inequal( one, two ) = {
  test::assert_ints( FALSE, one, two );
};
fun test_assert_ints ={
  expected =  1;
  result   =  1;
  test::assert_ints_are_equal( expected, result );

  expected =  1;
  result   =  2;
  test::assert_ints_are_inequal( expected, result );
};
# test_assert_ints();



fun assert_bools( type, expected, result ) = {
  if   ( type == TRUE  and expected == result )
    TRUE;
  elif ( type == FALSE and expected != result )
    TRUE;
  else
    print "\n  ** FAIL **\n";
    print "expected ";
    if ( expected ) print "TRUE"; else print "FALSE"; fi;
    print ", result ";
    if ( result ) print "TRUE\n"; else print "FALSE\n"; fi;
    FALSE;
  fi;
};
fun assert_bools_are_equal( expected, result ) = {
  test::assert_bools( TRUE, expected, result );
};
fun assert_bools_are_inequal( expected, result ) = {
  test::assert_bools( FALSE, expected, result );
};
fun test_assert_bools = {
  expected =  TRUE;
  result   =  TRUE;
  test::assert_bools_are_equal( expected, result );

  expected =  TRUE;
  result   =  FALSE;
  test::assert_bools_are_inequal( expected, result );

  expected =  FALSE;
  result   =  TRUE;
  test::assert_bools_are_inequal( expected, result );
};
# test_assert_bools();



fun test_assert_lists_of_strings = {
  expected =  [ "one", "two" ];
  result   =  expected;
  test::assert_lists_of_strings_are_equal( expected, result );

  # Different lengths
  expected =  [ "one", "two" ];
  result   =  [ "one" ];
  test::assert_lists_of_strings_are_inequal( expected, result );

  # Different content
  expected =  [ "one", "two" ];
  result   =  [ "three", "four" ];
  test::assert_lists_of_strings_are_inequal( expected, result );
};
# test_assert_lists_of_strings();



fun is_even( i: Int ):   Bool = {
  if ( ( i % 2 ) == 0 )
    TRUE;
  else
    FALSE;
  fi;
};
fun test_is_even( _: Void ):   Bool = {
  n =  2;
  expected =  TRUE;
  result =  is_even( n );
  test::assert_bools_are_equal( expected, result );

  n =  1;
  expected =  FALSE;
  result =  is_even( n );
  test::assert_bools_are_equal( expected, result );

  # Meant to fail.
  n =  1;
  expected =  TRUE;
  result =  is_even( n );
  test::assert_bools_are_equal( expected, result );
};
# test_is_even();


fun is_odd( i: Int ):   Bool = {
  if ( ( i % 2 ) == 0 )
    FALSE;
  else
    TRUE;
  fi;
};
fun test_is_odd( _: Void ):   Bool = {
  n =  1;
  expected =  TRUE;
  result =  is_odd( n );
  test::assert_bools_are_equal( expected, result );

  # Meant to fail.
  n =  2;
  expected =  FALSE;
  result =  is_odd( n );
  test::assert_bools_are_equal( expected, result );

  # Meant to fail.
  n =  2;
  expected =  TRUE;
  result =  is_odd( n );
  test::assert_bools_are_equal( expected, result );
};
# test_is_odd();






fun test_all_tests = {
  test_assert_strings();
  test_string_multiplier();

  # TODO:  Proper assertions.
#   test_list_of_strings_to_columnized_string();

  # TODO:  Proper assertions.
#   test_list_of_strings_to_columnized_string();

  # TODO:  Proper assertions.
#   test_two_strings_to_columnized_string();

  # TODO:  Proper assertions.
#   test_two_lists_of_strings_to_columnized_string();

  test_assert_ints();
  test_assert_bools();
  test_assert_lists_of_strings();

  # TODO:  test_not_equal
#   test_is_even();

  # TODO:  test_not_equal
#   test_is_odd();

};

};
